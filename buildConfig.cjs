const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

const CONFIGS_DIR = path.join(__dirname, "configs");
const DIST_DIR = path.join(__dirname, "dist");
const CSSO_COMMAND = "csso";

/**
 * Generates CSS variables for colors and their opacities.
 * @param {object} colors - The color configuration object (all colors).
 * @param {number[]} opacities - Array of opacity values.
 * @param {string[]} colorsWithOpacities - Array of color keys that need opacities. <-- NEW PARAM
 * @returns {string} The generated color CSS string.
 */
function generateColorCSS(colors, opacities, colorsWithOpacities = []) {
  let css = "";

  const colorsToProcess = new Set(colorsWithOpacities);

  for (const [name, rgb] of Object.entries(colors)) {
    const varNameBase = `--${name}-base`;
    const varName = `--${name}`;

    css += `  ${varNameBase}: ${rgb};\n`;
    css += `  ${varName}: rgba(var(${varNameBase}));\n`;

    if (colorsToProcess.has(name)) {
      for (const opacity of opacities) {
        const opacityPercentage = Math.round(opacity * 100);
        const varNameOpacity = `--${name}-${opacityPercentage}`;
        css += `  ${varNameOpacity}: rgba(var(${varNameBase}), ${opacity});\n`;
      }
    }

    css += "\n";
  }
  return css;
}

/**
 * Generates CSS variables for all fonts.
 * @param {object} fonts - The font configuration object.
 * @returns {string} The generated font CSS string.
 */
function generateFontCSS(fonts) {
  let css = "";
  for (const [name, value] of Object.entries(fonts)) {
    css += `  --${name}: ${value};\n`;
  }
  return css;
}

/**
 * Generates the CSS theme file for a single store, minifies it using CSSO.
 * @param {string} storeId - The store identifier.
 * @param {object} config - The configuration object for the store.
 */
function buildThemeCSS(storeId, config) {
  const { colors, fonts, opacities, colorWithOpacities } = config;
  const colorCSS = generateColorCSS(colors, opacities, colorWithOpacities);
  const fontCSS = generateFontCSS(fonts);

  const finalCSS = `/* Generated by buildConfig.cjs for ${storeId} - DO NOT EDIT MANUALLY */\n:root {\n${colorCSS}${fontCSS}}`;

  const OUTPUT_PATH = path.join(DIST_DIR, storeId, "theme.css");

  const TEMP_CSS_PATH = path.join(
    DIST_DIR,
    storeId,
    `theme-temp-${storeId}.css`
  );

  try {
    fs.writeFileSync(TEMP_CSS_PATH, finalCSS);

    const command = `${CSSO_COMMAND} ${TEMP_CSS_PATH} --output ${OUTPUT_PATH}`;
    execSync(command, { stdio: "pipe" });

    fs.unlinkSync(TEMP_CSS_PATH);
  } catch (error) {
    if (fs.existsSync(TEMP_CSS_PATH)) {
      fs.unlinkSync(TEMP_CSS_PATH);
    }

    if (
      error.message.includes("command not found") ||
      error.message.includes("No such file or directory")
    ) {
      console.error(
        `Failed to run csso. Make sure 'csso-cli' is installed and its bin is in your PATH (try running 'npm install csso-cli').`
      );
    } else {
      console.error(
        `Failed to minify theme.css for ${storeId}: ${
          error.message.trim().split("\n")[0]
        }`
      );
    }
  }
}

/**
 * Generates the JS config file (window.LOYALTY_PROTOCOL_CONFIG = storeConfig) for a single store.
 * @param {string} storeId - The store identifier.
 * @param {object} storeConfig - The store-specific configuration object.
 */
function buildStoreConfigJS(storeId, storeConfig) {
  const configContent = JSON.stringify(storeConfig, null, 2);
  const finalJS = `
window.LOYALTY_PROTOCOL_CONFIG = ${configContent};
`;
  const OUTPUT_PATH = path.join(DIST_DIR, storeId, "config.js");
  fs.writeFileSync(OUTPUT_PATH, finalJS.trim());
  console.log(`Wrote config.js`);
}

/**
 * Main function to iterate over all store configurations and build files.
 */
function buildAllThemes() {
  if (!fs.existsSync(CONFIGS_DIR)) {
    console.error(`Error: 'configs' directory not found at ${CONFIGS_DIR}`);
    return;
  }

  // Read directories for store identifiers
  const storeIdentifiers = fs
    .readdirSync(CONFIGS_DIR, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);

  if (storeIdentifiers.length === 0) {
    console.warn("No store identifiers found in the 'configs' directory.");
    return;
  }

  if (!fs.existsSync(DIST_DIR)) {
    fs.mkdirSync(DIST_DIR, { recursive: true });
  }

  for (const storeId of storeIdentifiers) {
    console.log(`\nProcessing store: ${storeId}`);

    const storePath = path.join(CONFIGS_DIR, storeId, "index.cjs");
    if (!fs.existsSync(storePath)) {
      console.error(
        `Error: index.cjs not found for ${storeId} at ${storePath}`
      );
      continue;
    }

    try {
      delete require.cache[require.resolve(storePath)];
      const loadedModule = require(storePath);

      const config = loadedModule.colors ? loadedModule : loadedModule.config;

      if (!config || !config.colors || !config.storeConfig) {
        console.error(
          `Error: Invalid configuration object loaded for ${storeId}. Missing 'colors' or 'storeConfig'.`
        );
        continue;
      }

      const storeDistDir = path.join(DIST_DIR, storeId);
      if (!fs.existsSync(storeDistDir)) {
        fs.mkdirSync(storeDistDir, { recursive: true });
      }

      buildThemeCSS(storeId, config);
      buildStoreConfigJS(storeId, config.storeConfig);
    } catch (error) {
      console.error(`Failed to process ${storeId}: ${error.message}`);
    }
  }

  console.log("\nBuild complete.");
}

buildAllThemes();
